}
# method - contrib
par(mar = c(5, 5, 4, 5),mfrow=c(1,2))
par(cex.axis = 1.7, cex.lab = 1.7)
for (k in seq(1:2)){
p_lon=which(lon_list==lon_val[k])
p_lat=which(lat_list==lat_val[k])
m1=bm_nbminAIC_1[p_lon,p_lat]
m2=bm_nbminAIC_2[p_lon,p_lat]
f=bf_nbminAIC[p_lon,p_lat]
ymin=0
ymax=max(c(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,],array_prob_marg[p_lon,p_lat,p_i2,p_i1,],
array_prob_dep[p_lon,p_lat,p_i2,p_i1,],array_prob_marg1[p_lon,p_lat,p_i2,p_i1,],
array_prob_marg2[p_lon,p_lat,p_i2,p_i1,],array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,2]))
# ymin=0
#  ymax=0.25
plot(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),type="l",col="black",ylim=c(ymin,ymax),lwd=3,xlab = "Years", ylab = "Probability",
main=title_point[k])
# points(x=(y_start+10),y=array_ci68_theta_prob_pref[p_lon,p_lat,p_i2,p_i1,1],col="red")
#  points(x=(y_start+10),y=array_ci68_theta_prob_pref[p_lon,p_lat,p_i2,p_i1,2],col="red")
# abline(h=array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,1],col="red",lty=2)
#  abline(h=array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,2],col="red",lty=2)
lines(array_prob_dep[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),col="chartreuse3",lwd=1.5,lty=1)
lines(array_prob_marg1[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),col="orange",lwd=1.5,lty=1)
lines(array_prob_marg2[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),col="magenta2",lwd=1.5,lty=1)
points(1960,array_prob_margdep[p_lon,p_lat,p_i2,p_i1,1],col="black",pch=16,cex=2)
abline(h=array_prob_margdep[p_lon,p_lat,p_i2,p_i1,1],col="black",lwd=0.5,lty=1)
if (k==1){
points(2005,array_prob_margdep[p_lon,p_lat,p_i2,p_i1,46],col="black",pch=16,cex=2)
points(2005,array_prob_dep[p_lon,p_lat,p_i2,p_i1,46],col="chartreuse3",pch=16,cex=2)
# points(2005,array_prob_marg1[p_lon,p_lat,p_i2,p_i1,46],col="orange",pch=16,cex=2)
#  points(2005,array_prob_marg2[p_lon,p_lat,p_i2,p_i1,46],col="magenta2",pch=16,cex=2)
abline(h=array_prob_margdep[p_lon,p_lat,p_i2,p_i1,46],col="black",lwd=0.5,lty=1)
abline(h=array_prob_dep[p_lon,p_lat,p_i2,p_i1,46],col="chartreuse3",lwd=0.5,lty=1)
# abline(h=array_prob_marg1[p_lon,p_lat,p_i2,p_i1,46],col="orange",lwd=0.5,lty=1)
# abline(h=array_prob_marg2[p_lon,p_lat,p_i2,p_i1,46],col="magenta2",lwd=0.5,lty=1)
}
if (k==2){
points(1986,array_prob_margdep[p_lon,p_lat,p_i2,p_i1,27],col="black",pch=16,cex=2)
# points(1986,array_prob_dep[p_lon,p_lat,p_i2,p_i1,27],col="chartreuse3",pch=16,cex=2)
points(1986,array_prob_marg1[p_lon,p_lat,p_i2,p_i1,27],col="orange",pch=16,cex=2)
#points(1986,array_prob_marg2[p_lon,p_lat,p_i2,p_i1,27],col="magenta2",pch=16,cex=2)
abline(h=array_prob_margdep[p_lon,p_lat,p_i2,p_i1,27],col="black",lwd=0.5,lty=1)
#  abline(h=array_prob_dep[p_lon,p_lat,p_i2,p_i1,27],col="chartreuse3",lwd=0.5,lty=1)
abline(h=array_prob_marg1[p_lon,p_lat,p_i2,p_i1,27],col="orange",lwd=0.5,lty=1)
#abline(h=array_prob_marg2[p_lon,p_lat,p_i2,p_i1,27],col="magenta2",lwd=0.5,lty=1)
}
m1="Gaussian"
legend("topleft",legend=c(expression(''*p *' '),substitute(paste(p[C]," (",f, " copula)"),list(f=f)),
substitute(paste(p['T']['max']," (",m1, " pdf)"),list(m1=m1)),
substitute(paste(p[S]," (",m2, " pdf)"),list(m2=m2))),
col = c( "black","chartreuse3","orange","magenta2"),lty=c(1,1,1,1),lwd=c(3,1.5,1.5,1.5),cex=1.1)
text(x = 2010, y = round((ymax-ymax/25),3),
labels = paste0("(",letters[k],")"), pos = 1, offset = 0.5, col = "black",cex=1.5)
}
# method - contrib
par(mar = c(5, 5, 4, 5),mfrow=c(1,2))
par(cex.axis = 1.7, cex.lab = 1.7)
for (k in seq(1:2)){
p_lon=which(lon_list==lon_val[k])
p_lat=which(lat_list==lat_val[k])
m1=bm_nbminAIC_1[p_lon,p_lat]
m2=bm_nbminAIC_2[p_lon,p_lat]
f=bf_nbminAIC[p_lon,p_lat]
ymin=0
ymax=max(c(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,],array_prob_marg[p_lon,p_lat,p_i2,p_i1,],
array_prob_dep[p_lon,p_lat,p_i2,p_i1,],array_prob_marg1[p_lon,p_lat,p_i2,p_i1,],
array_prob_marg2[p_lon,p_lat,p_i2,p_i1,],array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,2]))
# ymin=0
#  ymax=0.25
plot(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),type="l",col="black",ylim=c(ymin,ymax),lwd=3,xlab = "Years", ylab = "Probability",
main=title_point[k])
# points(x=(y_start+10),y=array_ci68_theta_prob_pref[p_lon,p_lat,p_i2,p_i1,1],col="red")
#  points(x=(y_start+10),y=array_ci68_theta_prob_pref[p_lon,p_lat,p_i2,p_i1,2],col="red")
# abline(h=array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,1],col="red",lty=2)
#  abline(h=array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,2],col="red",lty=2)
lines(array_prob_dep[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),col="chartreuse3",lwd=1.5,lty=1)
lines(array_prob_marg1[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),col="orange",lwd=1.5,lty=1)
lines(array_prob_marg2[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),col="magenta2",lwd=1.5,lty=1)
points(1960,array_prob_margdep[p_lon,p_lat,p_i2,p_i1,1],col="black",pch=16,cex=2)
abline(h=array_prob_margdep[p_lon,p_lat,p_i2,p_i1,1],col="black",lwd=0.5,lty=1)
if (k==1){
points(2006,array_prob_margdep[p_lon,p_lat,p_i2,p_i1,47],col="black",pch=16,cex=2)
points(2006,array_prob_dep[p_lon,p_lat,p_i2,p_i1,47],col="chartreuse3",pch=16,cex=2)
# points(2006,array_prob_marg1[p_lon,p_lat,p_i2,p_i1,47],col="orange",pch=16,cex=2)
#  points(2006,array_prob_marg2[p_lon,p_lat,p_i2,p_i1,47],col="magenta2",pch=16,cex=2)
abline(h=array_prob_margdep[p_lon,p_lat,p_i2,p_i1,47],col="black",lwd=0.5,lty=1)
abline(h=array_prob_dep[p_lon,p_lat,p_i2,p_i1,47],col="chartreuse3",lwd=0.5,lty=1)
# abline(h=array_prob_marg1[p_lon,p_lat,p_i2,p_i1,47],col="orange",lwd=0.5,lty=1)
# abline(h=array_prob_marg2[p_lon,p_lat,p_i2,p_i1,47],col="magenta2",lwd=0.5,lty=1)
}
if (k==2){
points(1986,array_prob_margdep[p_lon,p_lat,p_i2,p_i1,27],col="black",pch=16,cex=2)
# points(1986,array_prob_dep[p_lon,p_lat,p_i2,p_i1,27],col="chartreuse3",pch=16,cex=2)
points(1986,array_prob_marg1[p_lon,p_lat,p_i2,p_i1,27],col="orange",pch=16,cex=2)
#points(1986,array_prob_marg2[p_lon,p_lat,p_i2,p_i1,27],col="magenta2",pch=16,cex=2)
abline(h=array_prob_margdep[p_lon,p_lat,p_i2,p_i1,27],col="black",lwd=0.5,lty=1)
#  abline(h=array_prob_dep[p_lon,p_lat,p_i2,p_i1,27],col="chartreuse3",lwd=0.5,lty=1)
abline(h=array_prob_marg1[p_lon,p_lat,p_i2,p_i1,27],col="orange",lwd=0.5,lty=1)
#abline(h=array_prob_marg2[p_lon,p_lat,p_i2,p_i1,27],col="magenta2",lwd=0.5,lty=1)
}
m1="Gaussian"
legend("topleft",legend=c(expression(''*p *' '),substitute(paste(p[C]," (",f, " copula)"),list(f=f)),
substitute(paste(p['T']['max']," (",m1, " pdf)"),list(m1=m1)),
substitute(paste(p[S]," (",m2, " pdf)"),list(m2=m2))),
col = c( "black","chartreuse3","orange","magenta2"),lty=c(1,1,1,1),lwd=c(3,1.5,1.5,1.5),cex=1.1)
text(x = 2010, y = round((ymax-ymax/25),3),
labels = paste0("(",letters[k],")"), pos = 1, offset = 0.5, col = "black",cex=1.5)
}
# method - Diff TOE and diff POE
par(mar = c(5, 5, 4, 5),mfrow=c(1,2))
par(cex.axis = 1.7, cex.lab = 1.7)
for (k in seq(1:2)){
p_lon=which(lon_list==lon_val[k])
p_lat=which(lat_list==lat_val[k])
m1=bm_nbminAIC_1[p_lon,p_lat]
m2=bm_nbminAIC_2[p_lon,p_lat]
f=bf_nbminAIC[p_lon,p_lat]
ymin=0
ymax=max(c(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,],array_prob_marg[p_lon,p_lat,p_i2,p_i1,],
array_prob_dep[p_lon,p_lat,p_i2,p_i1,],array_prob_marg1[p_lon,p_lat,p_i2,p_i1,],
array_prob_marg2[p_lon,p_lat,p_i2,p_i1,],array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,2]))
plot(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),type="l",col="black",ylim=c(ymin,ymax),lwd=3,xlab = "Years", ylab = "Probability",
main=title_point[k])
abline(h=array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,1],col="red",lty=2)
abline(h=array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,2],col="red",lty=2)
lines(array_prob_marg[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),col="blue",lwd=1.5,lty=1)
Toe_margdep=compute_map_poe_metric(n_lon,n_lat,array_prob_margdep,p_i1,p_i2,"Contrib","above",window_size)$TOE_above
abline(v=Toe_margdep[p_lon,p_lat],col='black',lty=2,lwd=3)
Toe_marg=compute_map_poe_metric(n_lon,n_lat,array_prob_marg,p_i1,p_i2,"Contrib","above",window_size)$TOE_above
abline(v=Toe_marg[p_lon,p_lat],col='blue',lty=2,lwd=3)
#expression('('*H[2]~ 'O :ml' ~cm^2*')'))
m1="Gaussian"
legend("topleft",legend=c("Natural variability",expression(''*p *' '),expression(p['S,']['T']['max']),
expression("ToE"["upper"]),expression("ToE"["upper"]["(constant copula)"])),
col = c("red", "black","blue","black","blue"),lty=c(2,1,1,2,2),lwd=c(2,3,1.5,3,3),cex=1.1)
text(x = 2010, y = round((ymax-ymax/25),3),
labels = paste0("(",letters[k],")"), pos = 1, offset = 0.5, col = "black",cex=1.5)
}
# method - POE
par(mar = c(5, 5, 4, 5),mfrow=c(1,2))
par(cex.axis = 1.7, cex.lab = 1.7)
for (k in seq(1:2)){
p_lon=which(lon_list==lon_val[k])
p_lat=which(lat_list==lat_val[k])
ymin=0
ymax=max(c(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,],array_prob_marg[p_lon,p_lat,p_i2,p_i1,],
array_prob_dep[p_lon,p_lat,p_i2,p_i1,],array_prob_marg1[p_lon,p_lat,p_i2,p_i1,],
array_prob_marg2[p_lon,p_lat,p_i2,p_i1,],array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,2]))
plot(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,]~c((y_start+10):(y_end-9)),type="l",col="black",ylim=c(ymin,ymax),lwd=2,xlab = "Years", ylab = "Probability",
main=title_point[k])
lines(mobile_mean(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,],window_size)~c((y_start+12):(y_end-11)),col='brown')
low_bound=array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,1]
high_bound=array_ci68_thetamarg_prob_pref[p_lon,p_lat,p_i2,p_i1,2]
Poe_res1 = compute_PoE(array_prob_margdep[p_lon,p_lat,p_i2,p_i1,], low_bound, high_bound,
Length_SlidingWindow, period,mobile_mean=TRUE,window_size=window_size)
#abline(v=Poe_res1$year_start_POE_above,col='green',lty=1)
#abline(v=Poe_res1$year_start_POE_above+Poe_res1$length_POE_above-1,col='green')
rect(xleft = Poe_res1$year_start_POE_above, xright = Poe_res1$year_start_POE_above+Poe_res1$length_POE_above-1,
ybottom = par("usr")[3], ytop = par("usr")[4],
border = NA, col = adjustcolor("green", alpha = 0.15))
Toe=compute_map_poe_metric(n_lon,n_lat,array_prob_margdep,p_i1,p_i2,"Contrib","above",window_size)$TOE_above
abline(v=Toe[p_lon,p_lat],col='chartreuse3',lty=2,lwd=3)
abline(h=low_bound,col="red",lty=2)
abline(h=high_bound,col="red",lty=2)
if(k==1){
#abline(v=Poe_res1$year_start_POE_below,col='blue',lty=1)
#abline(v=Poe_res1$year_start_POE_below+Poe_res1$length_POE_below-1,col='blue')
rect(xleft = Poe_res1$year_start_POE_below, xright = Poe_res1$year_start_POE_below+Poe_res1$length_POE_below-1,
ybottom = par("usr")[3], ytop = par("usr")[4],
border = NA, col = adjustcolor("blue", alpha = 0.15))
legend(x = "topleft",legend = c( "Natural variability","p","smoothed p",expression("PoE"["lower"]),expression("PoE"["upper"]),expression("ToE"["upper"])),lwd = c(2,3,1,18,18,5),lty=c(2,1,1,1,1,3),
col = c("red","black","brown",adjustcolor("blue", alpha = 0.15),adjustcolor("green", alpha = 0.15),"chartreuse3"),cex=1)
}
else{
legend(x = "topleft",legend = c("Natural variability","p","smoothed p",expression("PoE"["upper"]),expression("ToE"["upper"])),lwd = c(2,3,1,18,5),lty=c(2,1,1,1,3),
col =c("red","black","brown",adjustcolor("green", alpha = 0.15),"chartreuse3"),cex=1)
}
text(x = 2010, y = round((ymax-ymax/25),3),
labels = paste0("(",letters[k],")"), pos = 1, offset = 0.5, col = "black",cex=1.5)
}
# Fonction en escalier
step_function <- function(x) {
if (x < 0) {
return(0)
} else if (x < 2) {
return(1)
} else if (x < 4) {
return(2)
} else if (x < 6) {
return(3)
} else {
return(4)
}
}
# Tester la fonction sur une séquence de valeurs
x_values <- seq(-1, 7, by=0.1)
y_values <- sapply(x_values, step_function)
# Visualisation de la fonction en escalier
plot(x_values, y_values, type = "s", lwd = 2, col = "blue",
xlab = "x", ylab = "step_function(x)",
main = "Fonction en escalier")
x
x_values
y_values
cor.test(x_values,y_values, method="kendall")
cor.test(x_values,y_values, method="spearman")
# Générer des données avec une relation exponentielle
set.seed(42)  # Pour la reproductibilité
x <- 1:10  # Variable indépendante
y <- exp(x)  # Variable dépendante avec relation exponentielle
# Ajouter un peu de bruit pour rendre le cas plus réaliste
y <- y + rnorm(length(y), mean = 0, sd = 50)
# Calculer les coefficients de corrélation
spearman_rho <- cor(x, y, method = "spearman")
kendall_tau <- cor(x, y, method = "kendall")
# Afficher les résultats
print(paste("Spearman's rho:", spearman_rho))
print(paste("Kendall's tau:", kendall_tau))
plot(x,y)
plot(x,y,type="s")
plot(x,y,type="l")
x <- 1:100  # Variable indépendante
y <- exp(x)  # Variable dépendante avec relation exponentielle
# Ajouter un peu de bruit pour rendre le cas plus réaliste
y <- y + rnorm(length(y), mean = 0, sd = 50)
# Calculer les coefficients de corrélation
spearman_rho <- cor(x, y, method = "spearman")
kendall_tau <- cor(x, y, method = "kendall")
# Afficher les résultats
print(paste("Spearman's rho:", spearman_rho))
print(paste("Kendall's tau:", kendall_tau))
plot(x,y,type="l")
x <- 1:10  # Variable indépendante
y <- exp(x)  # Variable dépendante avec relation exponentielle
# Ajouter un peu de bruit pour rendre le cas plus réaliste
y <- y + rnorm(length(y), mean = 0, sd = 50)
# Calculer les coefficients de corrélation
spearman_rho <- cor(x, y, method = "spearman")
kendall_tau <- cor(x, y, method = "kendall")
# Afficher les résultats
print(paste("Spearman's rho:", spearman_rho))
print(paste("Kendall's tau:", kendall_tau))
plot(x,y,type="l")
x <- 1:10  # Variable indépendante
y <- exp(x)  # Variable dépendante avec relation exponentielle
# Ajouter un peu de bruit pour rendre le cas plus réaliste
y <- y + rnorm(length(y), mean = 0, sd = 50)
# Calculer les coefficients de corrélation
spearman_rho <- cor(x, y, method = "spearman")
kendall_tau <- cor(x, y, method = "kendall")
# Afficher les résultats
print(paste("Spearman's rho:", spearman_rho))
print(paste("Kendall's tau:", kendall_tau))
plot(x,y,type="l")
?rcopula
# Paramètres pour les lois normales
mean_X <- 0
sd_X <- 1
mean_Y <- 0
sd_Y <- 1
# Taille de l'échantillon
n <- 1000
# Paramètre pour la copule de Clayton
theta_clayton <- 2  # Dépendance positive
# Création de la copule de Clayton
clayton_cop <- claytonCopula(theta_clayton)
library(copula)
# Paramètres pour les lois normales
mean_X <- 0
sd_X <- 1
mean_Y <- 0
sd_Y <- 1
# Taille de l'échantillon
n <- 1000
# Paramètre pour la copule de Clayton
theta_clayton <- 2  # Dépendance positive
# Création de la copule de Clayton
clayton_cop <- claytonCopula(theta_clayton)
# Génération de données uniformes avec la copule de Clayton
u_clayton <- rCopula(n, clayton_cop)
# Transformation en marges normales
X_clayton <- qnorm(u_clayton[,1], mean = mean_X, sd = sd_X)
Y_clayton <- qnorm(u_clayton[,2], mean = mean_Y, sd = sd_Y)
# Visualisation des données générées
plot(X_clayton, Y_clayton, main = "Données avec Copule de Clayton",
xlab = "X", ylab = "Y", col = "blue", pch = 19)
u_clayton
X_clayton
plot(density(X_clayton))
plot(density(Y_clayton))
mean_X <- 0
sd_X <- 1
mean_Y <- 0
sd_Y <- 1
# Taille de l'échantillon
n <- 2000
# Paramètre pour la copule de Clayton
theta_clayton <- 2  # Dépendance positive
# Création de la copule de Clayton
clayton_cop <- claytonCopula(theta_clayton)
# Génération de données uniformes avec la copule de Clayton
u_clayton <- rCopula(n, clayton_cop)
# Transformation en marges normales
X_clayton <- qnorm(u_clayton[,1], mean = mean_X, sd = sd_X)
Y_clayton <- qnorm(u_clayton[,2], mean = mean_Y, sd = sd_Y)
# Visualisation des données générées
plot(X_clayton, Y_clayton, main = "Données avec Copule de Clayton",
xlab = "X", ylab = "Y", col = "blue", pch = 19)
plot(density(X_clayton))
plot(density(Y_clayton))
plot(density(X_clayton))
plot(density(Y_clayton))
plot(density(X_clayton),xlim=c(-4,4))
plot(density(Y_clayton),xlim=c(-4,4))
# Taille de l'échantillon
n <- 5000
# Paramètre pour la copule de Clayton
theta_clayton <- 2  # Dépendance positive
# Création de la copule de Clayton
clayton_cop <- claytonCopula(theta_clayton)
# Génération de données uniformes avec la copule de Clayton
u_clayton <- rCopula(n, clayton_cop)
# Transformation en marges normales
X_clayton <- qnorm(u_clayton[,1], mean = mean_X, sd = sd_X)
Y_clayton <- qnorm(u_clayton[,2], mean = mean_Y, sd = sd_Y)
plot(X_clayton, Y_clayton, main = "Données avec Copule de Clayton",
xlab = "X", ylab = "Y", col = "blue", pch = 19)
plot(density(X_clayton),xlim=c(-4,4))
plot(density(Y_clayton),xlim=c(-4,4))
# Paramètre pour la copule normale (correlation)
rho_normal <- 0.7  # Corrélation positive
# Création de la copule normale
normal_cop <- normalCopula(rho_normal)
# Génération de données uniformes avec la copule normale
u_normal <- rCopula(n, normal_cop)
# Transformation en marges normales
X_normal <- qnorm(u_normal[,1], mean = mean_X, sd = sd_X)
Y_normal <- qnorm(u_normal[,2], mean = mean_Y, sd = sd_Y)
# Visualisation des données générées
plot(X_normal, Y_normal, main = "Données avec Copule Normale",
xlab = "X", ylab = "Y", col = "red", pch = 19)
# Taille de l'échantillon
n <- 5000
# Paramètre pour la copule de Clayton
theta_clayton <- 2  # Dépendance positive
# Création de la copule de Clayton
clayton_cop <- claytonCopula(theta_clayton)
# Génération de données uniformes avec la copule de Clayton
u_clayton <- rCopula(n, clayton_cop)
# Transformation en marges normales
X_clayton <- qnorm(u_clayton[,1], mean = mean_X, sd = sd_X)
Y_clayton <- qnorm(u_clayton[,2], mean = mean_Y, sd = sd_Y)
# Visualisation des données générées
plot(X_clayton, Y_clayton, main = "Données avec Copule de Clayton",
xlab = "X", ylab = "Y", col = "blue", pch = 19)
plot(density(X_clayton),xlim=c(-4,4))
plot(density(Y_clayton),xlim=c(-4,4))
plot(density(X_clayton),xlim=c(-4,4))
plot(density(Y_clayton),xlim=c(-4,4))
plot(X_clayton, Y_clayton, main = "Données avec Copule de Clayton",
xlab = "X", ylab = "Y", col = "blue", pch = 19)
library(ncdf4)
#### extract the data ####
path_var1="/Users/jschmutz/Documents/LSCE/code/Demo/job_to_launch/demo_HD_for_pCE_grid/ERA5_France_MaxMax_TEMP_1950_2022.nc"
path_var2="/Users/jschmutz/Documents/LSCE/code/Demo/job_to_launch/demo_HD_for_pCE_grid/ERA5_France_SPEI6_1950_2022.nc"
var1="tmax"
var2="spei6"
data1_nc = nc_open(path_var1)
data1 = ncvar_get(data1_nc,var1)
data2_nc = nc_open(path_var2)
data2 = ncvar_get(data2_nc,var2)
DATES_ce = atoms(timeSequence(from="1950-01-01",to="2022-12-31",by='month'))
?atoms
??atoms
library(ncdf4)
library(timeDate)
#### extract the data ####
path_var1="/Users/jschmutz/Documents/LSCE/code/Demo/job_to_launch/demo_HD_for_pCE_grid/ERA5_France_MaxMax_TEMP_1950_2022.nc"
path_var2="/Users/jschmutz/Documents/LSCE/code/Demo/job_to_launch/demo_HD_for_pCE_grid/ERA5_France_SPEI6_1950_2022.nc"
var1="tmax"
var2="spei6"
data1_nc = nc_open(path_var1)
data1 = ncvar_get(data1_nc,var1)
data2_nc = nc_open(path_var2)
data2 = ncvar_get(data2_nc,var2)
DATES_ce = atoms(timeSequence(from="1950-01-01",to="2022-12-31",by='month'))
Ind_summer_1950_2022 = which(is.element(DATES_ce[,2],summer))
path_var1="/Users/jschmutz/Documents/LSCE/code/Demo/job_to_launch/demo_HD_for_pCE_grid/ERA5_France_MaxMax_TEMP_1950_2022.nc"
path_var2="/Users/jschmutz/Documents/LSCE/code/Demo/job_to_launch/demo_HD_for_pCE_grid/ERA5_France_SPEI6_1950_2022.nc"
var1="tmax"
var2="spei6"
data1_nc = nc_open(path_var1)
data1 = ncvar_get(data1_nc,var1)
data2_nc = nc_open(path_var2)
data2 = ncvar_get(data2_nc,var2)
summer = c(6, 7, 8)
DATES_ce = atoms(timeSequence(from="1950-01-01",to="2022-12-31",by='month'))
Ind_summer_1950_2022 = which(is.element(DATES_ce[,2],summer))
index1=data1[,,Ind_summer_1950_2022]-273.15 # convert to °
index2=-data2[,,Ind_summer_1950_2022] # compute -spei6
index1[is.nan(index2)]=NaN # put nan where the index 2 have nan
n_lon=dim(index1)[1]
n_lat=dim(index1)[2]
n_lon
n_lat
n_lon=dim(index1)[1]
n_lat=dim(index1)[2]
lon_list=seq(-4.75,10,0.25)
lat_list=seq(51.5,41.25,-0.25)
#### plot the data ####
# in the south (var department)
lon_val=6.25
lat_val=43.5
p_lon=which(lon_list==lon_val)
p_lat=which(lat_list==lat_val)
points(index1[p_lon,p_lat],index2[p_lon,p_lat])
index1[p_lon,p_lat]
index1
dim(index1)
points(index1[p_lon,p_lat,],index2[p_lon,p_lat,])
index1[p_lon,p_lat,]
index2[p_lon,p_lat,]
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,])
var1_plot="max Tmax"
var2_plot="drought index"
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,],x_lab=var1_plot,y_lab=var2_plot,pch=19)
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,],xlab=var1_plot,ylab=var2_plot,pch=19)
warnings()
dim(index1[p_lon,p_lat,])
dim(index1)
73*3
plot(index1[p_lon,p_lat,211:219],index2[p_lon,p_lat,211:219],xlab=var1_plot,ylab=var2_plot,pch=19,col="red") # 2020/2021/2022
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,],xlab=var1_plot,ylab=var2_plot,pch=19)
points(index1[p_lon,p_lat,211:219],index2[p_lon,p_lat,211:219],xlab=var1_plot,ylab=var2_plot,pch=19,col="red") # 2020/2021/2022
cor_pearson = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="pearson")
cor_pearson
cor_kendall = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="kendall")
cor_kendall
cor_spearman = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="spearman")
cor(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="spearman")
cor(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="pearson")
# in the south (var department)
lon_val=6.25
lat_val=43.75
p_lon=which(lon_list==lon_val)
p_lat=which(lat_list==lat_val)
#### plot the data ####
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,],xlab=var1_plot,ylab=var2_plot,pch=19)
points(index1[p_lon,p_lat,211:219],index2[p_lon,p_lat,211:219],xlab=var1_plot,ylab=var2_plot,pch=19,col="red") # 2020/2021/2022
cor_pearson = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="pearson") #=0.37
cor_kendall = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="kendall") #=0.26
cor_spearman = cor(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="spearman") #=0.37
cor_kendall
# in the south (var department)
lon_val=5
lat_val=44
p_lon=which(lon_list==lon_val)
p_lat=which(lat_list==lat_val)
#### plot the data ####
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,],xlab=var1_plot,ylab=var2_plot,pch=19)
points(index1[p_lon,p_lat,211:219],index2[p_lon,p_lat,211:219],xlab=var1_plot,ylab=var2_plot,pch=19,col="red") # 2020/2021/2022
lon_val=5
lat_val=45
p_lon=which(lon_list==lon_val)
p_lat=which(lat_list==lat_val)
#### plot the data ####
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,],xlab=var1_plot,ylab=var2_plot,pch=19)
points(index1[p_lon,p_lat,211:219],index2[p_lon,p_lat,211:219],xlab=var1_plot,ylab=var2_plot,pch=19,col="red") # 2020/2021/2022
#### dependence measures ####
cor_pearson = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="pearson") #=0.37
cor_kendall = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="kendall") #=0.26
cor_spearman = cor(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="spearman") #=0.37
# in the south (var department)
lon_val=6.25
lat_val=43.5
p_lon=which(lon_list==lon_val)
p_lat=which(lat_list==lat_val)
#### plot the data ####
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,],xlab=var1_plot,ylab=var2_plot,pch=19)
points(index1[p_lon,p_lat,211:219],index2[p_lon,p_lat,211:219],xlab=var1_plot,ylab=var2_plot,pch=19,col="red") # 2020/2021/2022
cor_pearson = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="pearson") #=0.37
cor_kendall = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="kendall") #=0.26
cor_spearman = cor(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="spearman") #=0.37
cor_spearman
# in the south (var department)
lon_val=5
lat_val=44
p_lon=which(lon_list==lon_val)
p_lat=which(lat_list==lat_val)
#### plot the data ####
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,],xlab=var1_plot,ylab=var2_plot,pch=19)
points(index1[p_lon,p_lat,211:219],index2[p_lon,p_lat,211:219],xlab=var1_plot,ylab=var2_plot,pch=19,col="red") # 2020/2021/2022
# in the south (var department)
lon_val=6.25
lat_val=43.5
p_lon=which(lon_list==lon_val)
p_lat=which(lat_list==lat_val)
#### plot the data ####
plot(index1[p_lon,p_lat,],index2[p_lon,p_lat,],xlab=var1_plot,ylab=var2_plot,pch=19)
points(index1[p_lon,p_lat,211:219],index2[p_lon,p_lat,211:219],xlab=var1_plot,ylab=var2_plot,pch=19,col="red") # 2020/2021/2022
#### dependence measures ####
cor_pearson = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="pearson") #=0.37
cor_kendall = cor.test(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="kendall") #=0.26
cor_spearman = cor(index1[p_lon,p_lat,],index2[p_lon,p_lat,],method="spearman") #=0.37
devtools::load_all()
stwd
stwd()
getwd()
setwd("Documents/LSCE/code/package/package_emergence_compound/emergence.compound")
devtools::load_all()
devtools::check()
